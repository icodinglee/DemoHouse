<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Array</title>
</head>
<body>
  <script type="text/javascript">

  //如何实现Array.prototype.forEach
  //  if(！Array.prototype.forEach){
  //     Array.prototype.forEach=function(fn){
  //       for(var i=0;i<this.length;i++){
  //         fn(this[i],i,this)
  //       }
  //     }
  //   }
  //   ["a","b","c"].forEach(function(value,index,array){
  //     assert(value,"is in positin"+index+"out of "+(arr.length-1))
  //   })


  window.onload=function(){
  //排序的一些常见方法
  //随机生成十个整数数字
  var arr=[]
  function randomNum(){
    for(var i=0;i<10;i++){
      arr.push(parseInt(Math.random()*100))
    }
  }
  randomNum();

  //数组排序第一种方法sort
  function fn1(){
    arr.sort(function(a,b){
      return a-b
    })
    return arr
  }
  console.log(fn1())

  //数组排序第二种方法　选择排序：在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。
  function fn2(arr){
   var len = arr.length,
       i, j, k, tmp;
   for(i=0; i<len; i++){
       k = i;
       for(j=i+1; j<len; j++){
           if(arr[j] < arr[k]) k = j;
       }
       if(k!=i){
           tmp = arr[k];
           arr[k] = arr[i];
           arr[i] = tmp;
       }
   }
   return arr;
}
console.log(fn2(arr))

//第三种　冒泡排序：通过在无序区的相邻元素的比较和替换，使较小的元素浮到最上面。
function fn4(arr){
    var len = arr.length,
        i, j, tmp;
    for(i=0; i<len; i++){
        for(j=len-1; j>i; j--){
            if(arr[j] < arr[j-1]){
                tmp = arr[j-1];
                arr[j-1] = arr[j];
                arr[j] = tmp;
            }
        }
    }
    return arr;
}
console.log(fn4(arr))

//自己写的排序
function fn5(arr){
  var len =arr.length;
  for(var i=0;i<len;i++){
    for (var j = i+1; j < len; j++) {
      if(arr[i]>arr[j]){
        var temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp
      }
    }
  }
  return arr
}
console.log(fn5(arr))

//快速排序
var quickSort = function(arr) {
　　if (arr.length <= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0];
　　var left = [];
　　var right = [];
　　for (var i = 0; i < arr.length; i++){
　　　　if (arr[i] < pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
　　return quickSort(left).concat([pivot], quickSort(right));
};
function fn6(arrs) {
  var t=quickSort(arrs)
  console.log(t)
  arr=t;
  return t
}
console.log(fn6(arr))
console.log(arr)


//快速排序详解：这个排序方法运算速度最快
//（1）在数据集之中，选择一个元素作为"基准"（pivot）。
//（2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
//(3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

//其他排序方法
//堆排序
//归并排序
//希尔排序
//二分插入排序

  }
  </script>
</body>
</html>
