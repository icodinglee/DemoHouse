# 正则表达式

```
- var regex = /xyz/;
- var regex = /xyz/;
```

- 正则对象的方法：将字符串作为参数，比如regex.test(string)。
- 字符串对象的方法：将正则对象作为参数，比如string.match(regex)

## 正则对象的属性和方法
- 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置

```
ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。
global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。
multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。

var r = /abc/igm;

r.ignoreCase // true
r.global // true
r.multiline // true
```
- 另一类是与修饰符无关的属性，主要是下面两个。

```
lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。
source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读

var r = /abc/igm;

r.lastIndex // 0
r.source // "abc"
```

## test()
- 正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。
- 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。

```
var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false
```
- 如果正则模式是一个空字符串，则匹配所有字符串。

## exec()
- 正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。

```
var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

r1.exec(s) // ["x"]
r2.exec(s) // null
```
- 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。

```
var s = '_x_x';
var r = /_(x)/;

r.exec(s) // ["_x", "x"]
上面代码的exec方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。
```
- 新属性：input：整个原字符串。　index：整个模式匹配成功的开始位置（从0开始计数）。

```
var r = /a(b+)a/;
var arr = r.exec('_abbba_aba_');

arr // ["abbba", "bbb"] 第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。

arr.index // 1 因为从原字符串的第二个位置开始匹配成功。
arr.input // "_abbba_aba_"
```
- 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始

```
var r = /a(b+)a/g;
var s = '_abbba_aba_';

while(true) {
  var match = r.exec(s);
  if (!match) break;
  console.log(match);
}

// ["abbba", "bbb", index: 1, input: "_abbba_aba_"]
// ["aba", "b", index: 7, input: "_abbba_aba_"]
```

- 正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。
- 如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。

## 字符串对象的方法
- match()：返回一个数组，成员是所有匹配的子字符串。
- search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
- replace()：按照给定的正则表达式进行替换，返回替换后的字符串。
- split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

### String.prototype.match()
- 字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。
- 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果

```
var r = /a|b/g;
r.lastIndex = 7;
'xaxb'.match(r) // ['a', 'b']
r.lastIndex // 0
```
- 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。

## String.prototype.search()
- 字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1
- 该方法会忽略g修饰符

## String.prototype.replace()
- 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容
str.replace(search, replacement)
- 搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

```
'aaa'.replace('a', 'b') // "baa"
'aaa'.replace(/a/, 'b') // "baa"
'aaa'.replace(/a/g, 'b') // "bbb"
```
- replace方法的一个应用，就是消除字符串首尾两端的空格。

```
var str = '  #id div.class  ';

str.replace(/^\s+|\s+$/g, '')
// "#id div.class"
```
- replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容
  - $& 指代匹配的子字符串。
  - $` 指代匹配结果前面的文本。
  - $' 指代匹配结果后面的文本。
  - $n 指代匹配成功的第n组内容，n是从1开始的自然数。
  - $$ 指代美元符号$。

```
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// "world hello"

'abc'.replace('b', '[$`-$&-$\']')
// "a[a-b-c]c"
```
- replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。

```
'3 and 5'.replace(/[0-9]+/g, function(match){
  return 2 * match;
})
// "6 and 10"

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.
```

### String.prototype.split()
- 字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组
str.split(separator, [limit])

```
// 非正则分隔
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

// 正则分隔，去除多余的空格
'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]

'aaa*a*'.split(/a*/)
// [ '', '*', '*' ]
上面代码的分割规则是0次或多次的a，由于正则默认是贪婪匹配，所以例一的第一个分隔符是aaa，第二个分割符是a，将字符串分成三个部分，包含开始处的空字符串。
```
- 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

```
'aaa*a*'.split(/(a*)/)
// [ '', 'aaa', '*', 'a', '*' ]
```

## 匹配规则
###　字面量字符和元字符
- 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”
#### （1）点字符（.)
- 点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。

```
c.t
上面代码中，c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot。
```

#### 位置字符
- ^ 表示字符串的开始位置
- $ 表示字符串的结束位置

#### 选择符　｜
- 竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog

```
// 匹配fred、barney、betty之中的一个
/fred|barney|betty/
```

```
/a( |\t)b/.test('a\tb') // true
上面代码指的是，a和b之间有一个空格或者一个制表符。
```

#### 转义符

```
- 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\
- 如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。
(new RegExp('1\+1')).test('1+1')
// false

(new RegExp('1\\+1')).test('1+1')
// true
```

### 特殊字符

```
\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
[\b] 匹配退格键(U+0008)，不要与\b混淆。
\n 匹配换行键。
\r 匹配回车键。
\t 匹配制表符tab（U+0009）。
\v 匹配垂直制表符（U+000B）。
\f 匹配换页符（U+000C）。
\0 匹配null字符（U+0000）。
\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的unicode字符。
```

### 字符类
- 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。

```
/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true
```

####　脱字符
- 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。

```
/[^abc]/.test('hello world') // true
/[^abc]/.test('bbc') // false
```
- 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。

```
var s = 'Please yes\nmake my day!';

s.match(/yes.*day/) // null
s.match(/yes[^]*day/) // [ 'yes\nmake my day']
```

####　连字符
- 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。

```
[0-9.,]
[0-9a-fA-F]
[a-zA-Z0-9-]
[1-31] //不代表1到31，只代表1到3。
```
- 字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9
- 连字符还可以用来指定Unicode字符的范围。

```
var str = "\u0130\u0131\u0132";
/[\u0128-\uFFFF]/.test(str)
// true
```
- 不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，表面上它是选中从大写的A到小写的z之间52个字母

```
/[A-z]/.test('\\') // true
上面代码中，由于反斜杠（\\）的ASCII码在大写字母与小写字母之间，结果会被选中
```

### 预定义模式

```
\d 匹配0-9之间的任一数字，相当于[0-9]。
\D 匹配所有0-9以外的字符，相当于[^0-9]。
\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
\s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
\S 匹配非空格的字符，相当于[^\t\r\n\v\f]。
\b 匹配词的边界。
\B 匹配非词边界，即在词的内部。
```

```
// \s的例子
/\s\w*/.exec('hello world') // [" world"]
```

- 正则表达式遇到换行符（\n）就会停止匹配

```
var html = "<b>Hello</b>\n<i>world!</i>";

/.*/.exec(html)[0]
// "<b>Hello</b>"
```

### 重复类
- 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次

```
/lo{2}k/.test('look') // true
/lo{2, 5}k/.test('looook') // true
```
### 量词
- 量词符用来设定某个模式出现的次数。

```
? 问号表示某个模式出现0次或1次，等同于{0, 1}。
* 星号表示某个模式出现0次或多次，等同于{0,}。
+ 加号表示某个模式出现1次或多次，等同于{1,}。
```

### 贪婪模式
- 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。
- 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号,一旦条件满足，就不再往下匹配。

```
var s = 'aaa';
s.match(/a+?/) // ["a"]
```
- 除了非贪婪模式的加号，还有非贪婪模式的星号（\*）和加号（+）。

```
*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。
```
### 修饰符
- 修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。
- （1）g修饰符

```
var regex = /b/g;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // false

正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配
```
- i修饰符:默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）
- m修饰符:m修饰符表示多行模式（multiline），会修改^和$的行为。加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。

```
/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true
```

```
/^b/m.test('a\nb') // true
匹配行首的b
```

### 组匹配
- 正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

```
]/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true
上面代码中，第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配“fred”这个词。
```
- 正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。
```
var m = 'abcabc'.match(/(.)b(.)/);
m
// ['abc', 'a', 'c']
```

- 在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号

```
/(.)b(.)\1b\2/.test("abcabc")
// true
```

```
/y((..)\2)\1/.test('yabababab') // true
```

### 非捕获组
- (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号

```
var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c"]
```
###  先行断言
- x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果
- 比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。

```
/Jack (?=Sprat|Frost)/.test('Jack Frost') // true
```
### 先行否定断言
- x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果

```
/\d+(?!\.)/.exec('3.14')
// ["14"]
```
